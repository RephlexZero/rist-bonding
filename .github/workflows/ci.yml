name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  PKG_CONFIG_PATH: /usr/lib/x86_64-linux-gnu/pkgconfig:/usr/share/pkgconfig

# Cancel in-progress runs of the same branch/PR to save CI minutes
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-push:
    name: Build & Push Container
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.image.outputs.image }}
      cache-hit: ${{ steps.cache-check.outputs.cache-hit }}
      should-build: ${{ steps.changes.outputs.should-build }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history for change detection
      
      - name: Check for Docker-related changes
        id: changes
        run: |
          # Check if this is the first commit or if Docker-related files changed
          if git rev-parse --verify HEAD~1 >/dev/null 2>&1; then
            # Check for changes in Docker-related files since last commit
            if git diff --name-only HEAD~1 HEAD | grep -E '^(Dockerfile|docker-compose.*\.yml|\.dockerignore)$'; then
              echo "should-build=true" >> $GITHUB_OUTPUT
              echo "ðŸ”¨ Docker-related files changed, will build"
            else
              echo "should-build=false" >> $GITHUB_OUTPUT
              echo "âœ… No Docker-related changes, checking for existing image"
            fi
          else
            # First commit, need to build
            echo "should-build=true" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ First commit, will build"
          fi
      
      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
          driver-opts: |
            image=moby/buildkit:buildx-stable-1
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Check if image exists (for non-Docker changes)
        id: cache-check
        if: steps.changes.outputs.should-build == 'false'
        run: |
          # Convert repository name to lowercase for Docker compliance
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          CURRENT_IMAGE="ghcr.io/${REPO_LOWER}/rist-bonding-dev:${{ github.sha }}"
          LATEST_IMAGE="ghcr.io/${REPO_LOWER}/rist-bonding-dev:latest"
          
          docker login ghcr.io -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }}
          
          if docker manifest inspect $CURRENT_IMAGE >/dev/null 2>&1; then
            echo "cache-hit=true" >> $GITHUB_OUTPUT
            echo "âœ… Found image for current SHA: $CURRENT_IMAGE"
          elif docker manifest inspect $LATEST_IMAGE >/dev/null 2>&1; then
            echo "cache-hit=true" >> $GITHUB_OUTPUT
            echo "âœ… Using latest image: $LATEST_IMAGE"
            # Update the image output to use latest instead of SHA
            echo "image=$LATEST_IMAGE" >> $GITHUB_OUTPUT
          else
            echo "cache-hit=false" >> $GITHUB_OUTPUT
            echo "âŒ No suitable image found, forcing build"
            echo "should-build=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Extract metadata
        id: meta
        if: steps.changes.outputs.should-build == 'true' || (steps.changes.outputs.should-build == 'false' && steps.cache-check.outputs.cache-hit == 'false')
        run: |
          # Convert repository name to lowercase
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "images=ghcr.io/${REPO_LOWER}/rist-bonding-dev" >> $GITHUB_OUTPUT
          
          # Generate tags
          TAGS=""
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            TAGS="ghcr.io/${REPO_LOWER}/rist-bonding-dev:pr-${{ github.event.number }}"
          else
            TAGS="ghcr.io/${REPO_LOWER}/rist-bonding-dev:${{ github.ref_name }}"
            TAGS="${TAGS},ghcr.io/${REPO_LOWER}/rist-bonding-dev:${{ github.ref_name }}-${{ github.sha }}"
            if [ "${{ github.ref_name }}" = "main" ]; then
              TAGS="${TAGS},ghcr.io/${REPO_LOWER}/rist-bonding-dev:latest"
            fi
          fi
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        if: steps.changes.outputs.should-build == 'true' || (steps.changes.outputs.should-build == 'false' && steps.cache-check.outputs.cache-hit == 'false')
        run: |
          # Convert repository name to lowercase
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          
          docker buildx build \
            --push \
            --tag "${{ steps.meta.outputs.tags }}" \
            --cache-from "type=gha" \
            --cache-from "type=registry,ref=ghcr.io/${REPO_LOWER}/rist-bonding-dev:buildcache" \
            --cache-to "type=gha,mode=max" \
            --cache-to "type=registry,ref=ghcr.io/${REPO_LOWER}/rist-bonding-dev:buildcache,mode=max" \
            --builder "${{ steps.buildx.outputs.name }}" \
            .
      
      - name: Output image reference
        id: image
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          if [ "${{ steps.cache-check.outputs.image }}" != "" ]; then
            # Use the image determined by cache check (might be latest)
            echo "image=${{ steps.cache-check.outputs.image }}" >> $GITHUB_OUTPUT
          else
            # Use SHA-based image for new builds
            echo "image=ghcr.io/${REPO_LOWER}/rist-bonding-dev:${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

  docker-ci:
    name: Docker CI Pipeline
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      contents: read
      packages: read
    container:
      image: ${{ needs.build-and-push.outputs.image }}
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
      options: --cap-add=NET_ADMIN
    steps:
      - name: Show build status
        run: |
          echo "Using image: ${{ needs.build-and-push.outputs.image }}"
          if [ "${{ needs.build-and-push.outputs.should-build }}" = "true" ]; then
            echo "ðŸ”¨ Using freshly built image (Docker files changed)"
          elif [ "${{ needs.build-and-push.outputs.cache-hit }}" = "true" ]; then
            echo "âœ… Using cached image (no Docker changes detected)"
          else
            echo "ðŸ”¨ Using fallback image (forced rebuild)"
          fi
      
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Verify environment
        run: |
          echo "=== Environment Check ==="
          echo "Rust version: $(cargo --version)"
          echo "GStreamer version: $(gst-inspect-1.0 --version)"
          echo "Working directory: $(pwd)"
          echo "User: $(whoami)"
          ls -la /workspace || echo "No /workspace directory"
      
      - name: Check formatting
        run: cargo fmt --all -- --check
      
      - name: Run clippy
        run: cargo clippy --workspace --all-targets --all-features -- -D warnings
      
      - name: Run unit tests
        run: cargo test --workspace --lib --locked --verbose
      
      - name: Run integration tests
        run: cargo test --workspace --test '*' --locked --verbose
        env:
          # Skip privileged network tests in CI
          SKIP_NETWORK_NAMESPACE_TESTS: "1"

  security-audit:
    name: Security Audit
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
      - name: Install cargo-audit
        run: cargo install --force cargo-audit
      - name: Run security audit
        run: cargo audit
